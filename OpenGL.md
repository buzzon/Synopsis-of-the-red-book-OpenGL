```c++
Глава 3. Вид// Плохая структура кода, но простая и рабочая
#include <все_что_необходимо.h> 
main()
{
	ИнициализироватьОкно(); // не OpenGL

    glClearColor(0.0,0.0,0.0); // Цвет окна при очистке, нужен только 1 раз
	glClear(GL_COLOR_BUFFER_BIT); // Очищает окно

    glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0); //Определяет координатную систему
	
    glColor3f(1.0,1.0,1.0); // Цвет для рисования объектов
    glBegin(GL_POLYGON);	// Начало объекта
		glVertex3f(0.25,0.25,0.0); // вершина с координатами (x,y,z)
		glVertex3f(0.75,0.25,0.0);
		glVertex3f(0.75,0.75,0.0);
		glVertex3f(0.25,0.75,0.0);
	glEnd();				// Конец объекта
    
	glFlush(); // Убедиться, что команды OpenGL были выполнены
    
	ОбновитьОкно(); // не OpenGL
}
```

Позже `ИнициализироватьОкно()` и `ОбновитьОкно()` будут заменены на реально работающие вызовы, которые, однако, требуют реструктуризации кода, что сделает его более эффективным. 

![Суффиксы команд и соответствующие им типы аргументов](\img\1.png)

# Заголовочные файлы

```c++
#include <windows.h>  // Доступ к WGL, включить до gl.h и glu.h

#include <GL/gl.h>
#include <GL/glu.h> 
// Или (второй вариант содержит больше информации)
#include <GL/glut.h> 

// Для С, не связано с графикой
#include <stdlib.h>
#include <stdio.h> 
```

# Сборка проекта

Microsoft Windows библиотека OpenGL (в любой ее реализации) представлена динамической библиотекой opengl32.dll, а GLU – файлом glu32.dll. Для названных динамических библиотек соответствующими библиотеками импорта являются opengl32.lib и glu32.lib, находящиеся, как правило, в одном из подкаталогов компилятора. 

#  Управление окном

`void glutInit (int argc, char **argv);`  - Инициализирует саму библиотеку GLUT.

`void glutInitDisplayMode (unsigned int mode); `  - Указывает режим отображения.

- `GLUT_RGBA` или `GLUT_INDEX` (для указания цветового режима)

- `GLUT_SINGLE` или `GLUT_DOUBLE` (для указания режима буферизации)

- `GLUT_DEPTH`, `GLUT_STENCIL`, `GLUT_ACCUN` (для включения различных буферов)

  

`void glutInitWindowSize (int width, int height);`   - Запрашивает окно опр. размера.

`void glutInitWindowPosition (int x, int y);` - Запрашивает окно в опр. месте.

`glutCreateWindow()` - Открывает окно с предварительно установленными характеристиками.

 Окно не отображается до того, как произведен вход в `glutMainLoop()`, поэтому до вызова этой функции нельзя рисовать что-либо в окно. 

# Функции управления событиями

После того, как окно создано, но до входа в главный цикл программы.

`void glutDisplayFunc (void (*func)(void)); `  - Позволяет указать функцию (аргументом func), которая будет вызываться каждый раз, когда содержимое окна требует перерисовки. Это может случиться, когда окно открывается, разворачивается, освобождается его часть, ранее перекрытая другим окном, или вызывается функция glutPostRedisplay().

`void glutReshapeFunc (void (*func)(int width, int height)); ` -  Позволяет указать функцию, которая вызывается каждый раз при изменении размера окна или его позиции на экране. 

`void glutKeyboardFunc (void (*func)(unsigned int key, int x, int y)); ` - Задает функцию func, которая вызывается, когда нажимается клавиша, имеющая ASCII-код. В параметрах x и y передается позиция курсора мыши (относительно окна) в момент нажатия клавиши. 

`void glutMouseFunc (void (*func)(int button, int state, int width, int height)); ` - Указывает функцию, которая вызывается при нажатии или отпускании кнопки мыши. 

Параметр button может иметь значения 
`GLUT_LEFT_BUTTON`, `GLUT_MIDDLE_BUTTON` или `GLUT_RIGHT_BUTTON` 

Параметр state может иметь значения `GLUT_UP` или `GLUT_DOWN`

`void glutMotionFunc (void (*func)(int x, int y)); ` - Указывает функцию, которая будет вызываться при движении мыши внутри окна в то время, как на ней нажата одна или несколько клавиш. 

`void glutPostRedisplay (void); ` - Помечает, что текущее окно требует перерисовки.

# Загрузка палитры

`void glutSetColor (Glint index, GLfloat red, GLfloat green, GLfloat blue); ` - Загружает в палитру по индексу index, RGB-значение, определенное параметрами red, green и blue. Последние три параметра нормализуются до диапазона [0.0, 1.0]. 

# Рисование трехмерных объектов

`void glutWire* (GLdouble radius, GLint slices, GLint stacks);`  - Рисует объект в виде проволочного каркаса и не генерирует нормалей.

`void glutSolid* (GLdouble radius, GLint slices, GLint stacks);` - Рисует объект сплошным и генерирует нормали поверхности.

# Управление фоновым процессом

`void glutIdleFunc (void (*func)(void)); ` - Указать функцию, которая будет вызываться в том случае, если нет других сообщений, то есть во время простоя приложения. Выполнение этой функции обратного вызова можно отменить передачей аргумента `NULL`. 

# Запуск программы

`void glutMainLoop (void); ` - Вводит программу в цикл обработки сообщений. Функции обратного вызова будут выполняться в случае наступления соответствующих событий.

```c++
#include <GL/glut.h> 
void init(void) // установка цвета фона и координатной системы, выполнить 1 раз
{
	//Выбрать фоновый (очищающий) цвет
	glClearColor(0.0,0.0,0.0,0.0); 
    
    //Установить проекцию
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity(); 
	glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0); 
}

void display(void)
{
	//Очистить экран 
    glClear(GL_COLOR_BUFFER_BIT);
    
	// Нарисовать белый полигон (квадрат) с углами 
    //в (0.25, 0.25, 0.0) и (0.75, 0.75, 0.0)
	glColor3f(1.0,1.0,1.0);
	glBegin(GL_POLYGON);
		glVertex3f(0.25,0.25,0.0);
		glVertex3f(0.75,0.25,0.0);
		glVertex3f(0.75,0.75,0.0);
		glVertex3f(0.25,0.75,0.0);
	glEnd();
    
	//Не ждем. Начинаем выполнять буферизованные команды OpenGL
	glFlush();
} 

//Установить начальные характеристики окна,
//открыть окно с заголовком «hello».
//Зарегистрировать дисплейную функцию обратного вызова
//Войти в главный цикл
int main(int argc, char **argv)
{
	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
	glutInitWindowSize(250,250);
	glutInitWindowPosition(100,100);
	glutCreateWindow(“hello”);
	init();
	glutDisplayFunc(display);
	glutMainLoop();
	return 0;
} 
```

# Двойная буферизация

`void glutSwapBuffers (void);` 

![Буферы](\img\2.png)

![](\img\3.png)

# Грани

`void glFrontFace (GLenum mode); ` - Указать OpenGL, что считать лицевыми и обратными гранями.

- `GL_CCW` ориентации против часовой стрелки
- `GL_CW` ориентации по часовой стрелке

#### механизм удаления нелицевых (обратных) граней

`void glCullFace (GLenum mode); ` -  Задает, какие полигоны должны игнорироваться и удаляться до их преобразования в экранные координаты.  Параметр mode может принимать значение `GL_FRONT`, `GL_BACK` или `GL_FRONT_AND_BACK`.

**`glEnable(GL_CULL_FACE)`** 

####  Шаблонирование полигонов

`void glPolygonStipple (const GLubyte *mask);` - Определяет текущий рисунок шаблона заливки полигона.  Параметр mask – это указатель на битовую карту размером 32 x 32 бита

Там, где стоит 1 – соответствующий пиксель полигона будет нарисован, а там, где появляется 0 – пиксель нарисован не будет.

**`glEnable(GL_POLYGON_STIPPLE);`**

# Нормали

Вектора нормалей остаются нормализованными до тех пор, пока вы используете только повороты и переносы своих объектов. 

Если же вы производите *масштабирование*, используете специфическую матрицу преобразования или изначально указываете ненормализованные вектора нормалей – вы должны заставить OpenGL нормализовать векторы после преобразований. `glEnable(GL_NORMALIZE). ` 



Если вы устанавливаете вектора нормали единичной длины и применяете только равномерное масштабирование (с сохранением одинаковых пропорций по всем осям), то для нормализации вы можете также использовать `glEnable(GL_RESCALE_NORMAL).`

# Вершинные массивы

Механизм вершинных массивов OpenGL позволяет вам указывать разнообразные данные, связанные с вершинами, при помощи всего нескольких массивов и получать доступ к этим данным при помощи всего нескольких вызовов команд.

Помещение данных в вершинные массивы может увеличить быстродействие вашего приложения. Использование вершинных массивов снижает количество вызовов функций, что увеличивает быстродействие. Кроме того, использование вершинных массивов может устранить избыточность при обработке общих вершин (но не обязательно – совместное использование вершин поддерживается не всеми реализациями OpenGL). 

Для визуализации геометрии с помощью вершинных массивов необходимо выполнить три шага:

1. Активизировать (включить) от одного до шести массивов, каждый из которых применяется для хранения различных данных: *координат вершин, RGBA – цветов, цветовых индексов, нормалей, координат текстуры или флагов ребра.* 

2. Поместить данные в массив или массивы. Доступ к массивам производится с помощью указателей на их местонахождение в памяти. В клиент-серверной модели эти данные сохраняются в адресном пространстве клиента.

3. Нарисовать геометрию с помощью имеющихся данных. OpenGL разрешает указатели и одновременно извлекает данные, касающиеся каждой вершины (координаты, цвет и так далее), из всех активизированных массивов. 

   Существует три варианта извлечения данных:

   1. Доступ к индивидуальным элементам массива (элементом вершинного массива считается фрагмент данных, относящихся к одной вершине – две координаты, тройка значений компонентов цвета и так далее).
   2. Создание списка индивидуальных элементов массива, которые нужно выбрать.
   3. Обработка последовательностей элементов массива. 

Смешанные вершинные массивы данных представляют собой другой часто
используемый метод организации. Вместо того, чтобы использовать до шести массивов,
содержащих разные типы данных, вы можете смешивать различные данные в одном
единственном массиве. 

### Шаг 1: Включение массивов

Первый шаг заключается в вызове `void glEnableClientState (GLenum array); ` с параметром, определяющим выбранный для активизации массив.

 Единственный параметр может принимать значения 

- `GL_VERTEX_ARRAY` (массив координат вершин)
- `GL_COLOR_ARRAY` (массив цветов в режиме RGBA)
- `GL_INDEX_ARRAY` (массив цветовых индексов для соответствующего режима)
- `GL_NORMAL_ARRAY` (массив координат векторов нормалей)
- `GL_TEXTURE_COORD_ARRAY` (массив координат текстуры)
- `GL_EDGE_FLAG_ARRAY` (массив значений флага ребра)

`void glDisableClientState (GLenum array);` - для отключения массивов.

### Шаг 2: Указание данных для массивов

`void glColorPointer (Glint size, GLenum type, GLsizei stride, const GLvoid *pointer);` 
`void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);` 
`void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);`
`void glTexCoordPointer (Glint size, GLenum type, GLsizei stride, const GLvoid *pointer);`
`void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);`
`void glVertexPointer (Glint size, GLenum type, GLsizei stride, const GLvoid *pointer);` - Позволяет указать, где находятся данные для массива <u>вершинных</u> координат. 

- `size` - количество координат на одну вершину, должен принимать значения 2, 3 или 4.
- `type` - задает тип данных для каждой координаты в массиве (GL_SHORT, GL_INT, GL_FLOAT ...). 
- `stride` - промежуток в памяти (в байтах) между первой координатой предыдущей и первой координатой следующей вершины. 
- `pointer` – это указатель на область памяти, где содержится первая координата первой вершины. 

![](\img\4.png)

#### Смещение

```c++
GLfloat interwined[]={
 1.0, 0.2, 1.0, 100.0, 100.0, 0.0,
 1.0, 0.2, 0.2, 0.0, 200.0, 0.0,
 1.0, 1.0, 0.2, 100.0, 300.0, 0.0,
 0.2, 1.0, 0.2, 200.0, 300.0, 0.0,
 0.2, 1.0, 1.0, 300.0, 200.0, 0.0,
 0.2, 0.2, 1.0, 200.0, 100.0, 0.0}; 
```

Чтобы сослаться только на цветовые значения массива interwined, следующий вызов начинает забирать данные из начала массива (указатель на которое передается в виде &interwined[0]), затем сдвигается на 6*sizeof(GLfloat), что является размером в байтах трех компонент цвета и трех координат одной вершины. Этого прыжка достаточно, чтобы попасть на начало цветовых данных для следующей вершины. 

`glColorPointer(3,GL_FLOAT,6*sizeof(GLfloat),&interwined[0]);` 

Для получения координат вершин, необходимо начать с 4-го элемента физического массива interwined (помните, что в C нумерация элементов массива начинается с 0). 

`glVertexPointer(3,GL_FLOAT, 6*sizeof(GLfloat),&interwined[3]);`

### Шаг 3: Разрешение данных

Данные могут быть извлечены из одного элемента массива (по его индексу), из упорядоченного списка элементов массива (который может определять какие именно данные следует обрабатывать, а какие нет) или из последовательности элементов массива. 

#### Разрешение одного элемента массива

`void glArrayElement (Glint ith); `- Извлекает данные для одной вершины с индексом ith из всех включенных в текущий момент массивов. 

Обычно `glArrayElement()` вызывается между командами `glBegin()` и `glEnd()`. Если `glArrayElement()` вызывается за пределами этих командных скобок, он устанавливает текущее значение для всех переменных состояния, соответствующих включенным массивам.

![image-20200218073934327](\img\5)

#### Разрешение списка элементов массива

команды `glDrawElements()` и `glDrawRangeElements() `удобны для проведения случайных выборок данных в более упорядоченной манере. 

`void glDrawElements (GLenum mode, GLsizei count, GLenum type, void *indices);` - Определяет последовательность геометрических примитивов, используя count элементов вершинных массивов, индексы которых находятся в массиве indices. type может принимать значение GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT или GL_UNSIGNED_INT, задавая тип данных в массиве indices. Параметр mode указывает, какие примитивы следует построить, и может принимать GL_POLYGON, GL_LINE_LOOP, GL_LINES, GL_POINTS и т. д.

 После исполнения `glDrawElements()` текущие RGB – цвет, цветовой индекс, координаты нормали, координаты текстуры и флаг ребра **не определены** *если во время вызова были включены соответствующие массивы.* 

```
int i;
glBegin(mode);
	for(i=0;i<COUNT;I++)
	glArrayElement(indices[i]);
glEnd(); 
```



![image-20200220073541362](\img\6_0.png)



![image-20200220073507373](\img\6.png)

####  Разрешение последовательности элементов массива

`void glDrawArrays (GLenum mode, Glint first, GLsizei count);` - Конструирует последовательность геометрических примитивов, используя элементы включенных вершинных массивов, начиная с индекса first и заканчивая индексом first+count-1. 

```
int i; 
glBegin(mode); 
	for(i=0;i<COUNT;I++)
		glArrayElement(first+i);
glEnd(); 
```

#### Смешанные массивы

Дополнительно: Ранее мы рассматривали специальный случай смешанного массива. Тогда в массиве **interwined** чередовались данные RGB –цветов и 3D – координат вершин. Доступ к ним был получен с помощью команд `glColorPointer()` и `glVertexPointer()` и правильного выбора значений параметра **stride**. 

```
GLfloat interwined[]=
{1.0, 0.2, 1.0, 100.0, 100.0, 0.0,
 1.0, 0.2, 0.2, 0.0, 200.0, 0.0,
 1.0, 1.0, 0.2, 100.0, 300.0, 0.0,
 0.2, 1.0, 0.2, 200.0, 300.0, 0.0, 
 0.2, 1.0, 1.0, 300.0, 200.0, 0.0,
 0.2, 0.2, 1.0, 200.0, 100.0, 0.0}; 
```

`void glInterleavedArrays (GLenum format, GLsizei stride, void *pointer);` - позволяет задавать несколько вершинных массивов за один вызов.

`glInterleavedArrays(GL_C3F_V3F, 0, interwined); `

Этот вызов **glInterleavedArrays()** включает массивы GL_COLOR_ARRAY и GL_VERTEX_ARRAY и выключает массивы GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY, GL_NORMAL_ARRAY и GL_EDGE_FLAG_ARRAY.

Кроме того, эта строка имеет тот же эффект, что и вызовы **glColorPointer()** и **glVertexPointer()**, задающие значения для шести вершин в каждом из указанных включаемых массивов. После этого можно переходить к *Шагу 3*.

###### Эффект от вызова glInterleavedArrays(format, stride, pointer) 

![image-20200220074957902](\img\7.png)

В таблице 2-5, T и F соответствуют True и False. f равно sizeof(GLfloat). с – sizeof(GLubyte)*4 (округленному до ближайшего произведения f, если необходимо).

![image-20200220075027949](\img\8.png)

# Группы атрибутов

![image-20200220075620416](\img\9.png)

# Советы по построению полигональных моделей и поверхностей

- Сохраняйте ориентацию всех полигонов одинаковой. Убедитесь, что при взгляде со стороны, все полигоны поверхности ориентированы в одном направлении (вершины всех полигонов расположены по часовой стрелке или против нее). Постоянство ориентации важно для отсечения нелицевых граней и двухстороннего освещения. Попытайтесь следовать этому правилу с самого начала, поскольку проблемы, связанные с его несоблюдением, очень сложно исправлять в дальнейшем. (Если вы используете glScale*() для отражения геометрии относительно какой-либо оси симметрии, вы можете изменить ориентацию с помощью glFrontFace() для сохранения ее постоянства.) 

- При делении поверхности отслеживайте любые не треугольные полигоны. Три вершины треугольника гарантированно лежат в одной плоскости; любой полигон с четырьмя и более вершинами не обязательно является плоским. При просмотре с определенных точек ребра такого полигона могут пересекаться, и OpenGL может неправильно его отобразить. 

- Помните, что всегда существует противоречие между скоростью графического вывода и качеством изображения. Если вы разделите поверхность на небольшое количество полигоны, они будут отображаться очень быстро, но такая поверхность будет иметь негладкий, угловатый вид; если вы разделите ее на миллионы крошечных полигонов, она будет очень хорошо выглядеть, но ее вывод займет намного больше времени. В идеале вы можете передавать в функцию или процедуру деления поверхности параметр, определяющий насколько качественное дробление вы хотите осуществить. В этом случае, если поверхность находится далеко от наблюдателя, вы можете использовать более грубое разделение поверхности. Кроме того, используйте большие полигоны для относительно плоских частей поверхности и большее количество маленьких полигонов для сильно изогнутых ее областей. 

- **Для высококачественных изображений неплохой идеей является разделение контура поверхности на большее число фрагментов, чем разделение внутренних частей. Это сложнее сделать, если предполагается, что поверхность будет вращаться, поскольку в этом случае ее видимый контур будет изменяться. Контурные ребра можно выявить с помощью векторов нормалей – в любой точке такого ребра вектор нормали перпендикулярен вектору из этой точки к точке обзора, то есть их скалярное произведение равно 0. Ваш алгоритм разделения поверхности может быть написан с учетом возможности выбора более частого дробления там, где произведение этих вектором приближается к 0.**

- Попытайтесь избежать T-пересечений в ваших моделях (рисунок 2-17). Нет гарантии, что сегменты AB и BC будут отображены на тех же пикселях, что и сегмент AC. Иногда это так, а иногда – нет, в зависимости от применяемых трансформаций и ориентации поверхности. Это может привести к появлению видимых «трещин» в поверхности.
  ![image-20200220080247420](C:\Users\buzzon\Desktop\OpenGL\img\10.png)

- Если вы строите замкнутую поверхность, при замыкании границы убедитесь, что используете точно те же значения координат для точек ее начала и конца, в противном случае, вы можете обнаружить видимые трещины в поверхности из-за арифметических округлений.

## Пример: Построение Икосаэдра

```
#define X .525731112119133606 
#define Z .850650808352039932

GLfloat vdata[12][3] = {
 {-X,0.0,Z},{X,0.0,Z},{-X,0.0,-Z},{X,0.0,-Z},
 {0.0,Z,X},{0.0,Z,-X},{0.0,-Z,X},{0.0,-Z,-X},
 {Z,X,0.0},{-Z,X,0.0},{Z,-X,0.0},{-Z,-X,0.0}
};

GLuint tindices[20][3] = {
 {1,4,0},{4,9,0},{4,5,9},{8,5,4},{1,8,4},
 {1,10,8},{10,3,8},{8,3,5},{3,2,5},{3,7,2},
 {3,10,7},{10,6,7},{6,11,7},{6,0,11},{6,1,0},
 {10,1,6},{11,0,9},{2,11,9},{5,2,9},{11,2,7}
};

int i;

glBegin(GL_TRIANGLES);
 for(i=0;i<20;i++)
{
 //Здесь помещается информация о цвете
 glVertex3fv(&vdata[tindices[i][0]][0]);
 glVertex3fv(&vdata[tindices[i][1]][0]);
 glVertex3fv(&vdata[tindices[i][2]][0]);
}
glEnd(); 
```

Странные числа X и Z выбраны таким образом, чтобы расстояние от точки начала координат до любой из вершин было равно 1.0. Координаты 12-ти вершин задаются в массиве vdata, где координаты нулевой вершины {-X,0.0,Z}, координаты первой {X,0.0,Z} и так далее. Массив tindices определяет, как нужно соединять вершины для получения нужных треугольников. Например, вершинами первого треугольника являются нулевая, четвертая и первая вершины из массива vdata. Если вершины для каждого треугольника будут выбираться согласно указанному порядку, все треугольники будут иметь одинаковую ориентацию.

Строка комментария о цветовой информации должна быть заменена командой, устанавливающей цвет для i-ой грани. Если это не будет сделано, все грани будут нарисованы одним цветом, и это приведет к невозможности визуального определения того, что объект является трехмерным. Вместо изменения цветов можно определить вектора нормалей и использовать освещение, как описано в следующем подразделе. 

```
Замечание: Во всех примерах данного раздела, если поверхность должна быть
нарисована более одного раза, вероятно, стоит сохранить вычисленные
координаты вершин и нормалей, чтобы не производить вычисления каждый раз при
рисовании поверхности. Вы можете сделать это посредством собственных структур
данных или списков отображения. 
```



### Расчет нормалей для поверхности

Если предполагается, что поверхность будет освещена, вам необходимо определить вектора нормалей к поверхности. Вектор нормали можно получить, вычислив нормализованное векторное произведение двух векторов на этой поверхности. Для каждой плоской части икосаэдра (то есть для каждого треугольника) все три вершины имеют одинаковый вектор нормали. Таким образом, нормаль должна быть определена единожды для каждого набора из трех вершин. Комментарий в предыдущем примере рисования икосаэдра может быть заменен на код из примера 2-14. 

Генерируем вектора нормалей к поверхности 2-14

```
GLfloat d1[3], d2[3], norm[3];
for(j=0;j<3;j++) 
{
	d1[j]=vdata[tindices[i][0]][j]-vdata[tindices[i][1]][j];
	d2[j]=vdata[tindices[i][1]][j]-vdata[tindices[i][2]][j];
}
normcrossprod(d1,d2,norm);
glNormal3fv(norm); 
```

Функция `normcrossprod()` вычисляет нормализованное векторное произведение двух векторов, как показано в примере 2-15. 

Пример 2-15. Вычисление нормализованного векторного произведения двух векторов

```
void normalize(float v[3])
{
 GLfloat d=sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
 if(d==0.0)
 {
 error(“Длина вектора равна 0”);
 return;
 }
 v[0]/=d;
 v[1]/=d;
 v[2]/=d;
}

void normcrossprod(float v1[3], float v2[3], float out[3])
{
 out[0]=v1[1]*v2[2]- v1[2]*v2[1];
 out[1]=v1[2]*v2[0]- v1[0]*v2[2];
 out[2]=v1[0]*v2[1]- v1[1]*v2[0];
 normalize(out);
} 
```

Если вы используете икосаэдр в качестве приближения равномерно закрашенной сферы, вам, возможно, потребуется использовать нормали, которые перпендикулярны истинной поверхности сферы, а не граням икосаэдра. Вектора нормалей для сферы вычисляются элементарно, поскольку в каждой точке вектор нормали совпадает с вектором из центра сферы в эту точку. Поскольку в приведенном примере икосаэдр имеет радиус равный 1, данные для нормалей и данные координат вершин совпадают. Далее приводится код, рисующий двадцатистороннюю аппроксимацию (икосаэдр) равномерно закрашенной сферы (в коде предполагается, что кроме прочего включено освещение): 

```
glBegin(GL_TRIANGLES);
 for(i=0;i<20;i++)
 {
 glNormal3fv(&vdata[tindices[i][0]][0]);
 glVertex3fv(&vdata[tindices[i][0]][0]);
 glNormal3fv(&vdata[tindices[i][1]][0]);
 glVertex3fv(&vdata[tindices[i][1]][0]);
 glNormal3fv(&vdata[tindices[i][2]][0]);
 glVertex3fv(&vdata[tindices[i][2]][0]);
 }
glEnd();
```

### Улучшаем модель

20-сторонняя аппроксимация сферы выглядит не лучшим образом, если только она не находится далеко от наблюдателя, однако существует простой способ улучшить качество изображения. Представьте себе, что икосаэдр вписан в сферу (то есть все вершины икосаэдра лежат на поверхности сферы) и разбейте каждый из его треугольников на 4, как показано на рисунке 2-18 (заметьте, что в правой части рисунка AD=DB=AB/2, BE=EC=DC/2 и AF=FC=AC/2). 

Рисунок 2-18. Разбиение треугольников

![image-20200220082003314](\img\2-18.png)

Появившиеся в результате новые вершины находятся внутри сферы, и мы должны притянуть их к поверхности сферы путем нормализации (делением координат вершин на некоторый коэффициент, в результате чего вектор из центра сферы к этой вершине будет иметь длину равную 1). Подобный процесс разбиения может быть повторен несколько раз для получения приближения требуемой точности. Объекты на рисунке 2-19 состоят из 20, 80 и 320 треугольников соответственно. 

Рисунок 2-19. Разбиение увеличивает гладкость полигональной модели

![image-20200220082043454](img\2-19.png)

Пример 2-16 производит одно дополнительное разбиение, создавая 80-стороннюю сферическую аппроксимацию.

Пример 2-16. Единичное разбиение

```c++
void drawTriangle(float *v1, float *v2, float *v3)
{
 glBegin(GL_TRIANGLES);
 	glNormal3fv(v1);
 	glVertex3fv(v1);
 	glNormal3fv(v2);
 	glVertex3fv(v2);
 	glNormal3fv(v3);
 	glVertex3fv(v3); 
 glEnd();
}

void subdivine(float *v1, float *v2, float *v3)
{
 GLfloat v12[3], v23[3], v31[3];
 GLint i;

 for (i=0;i<3;i++)
 {
 	v12[i]=(v1[i]+v2[i])/2.0;
 	v23[i]=(v2[i]+v3[i])/2.0;
 	v31[i]=(v3[i]+v1[i])/2.0;
 }
 normalize(v12);
 normalize(v23);
 normalize(v31);
 drawTriangle(v1,v12,v31);
 drawTriangle(v2,v23,v12);
 drawTriangle(v3,v31,v23);
 drawTriangle(v12,v23,v31);
}

for(i=0;i<20;i++)
{
 subdivine(&vdata[tindices[i][0]][0],
 &vdata[tindices[i][1]][0],
 &vdata[tindices[i][2]][0]);
} 
```

Пример 2-17 – это модификация примера 2-16, осуществляющая рекурсивное разбиение треугольников до заданной глубины. Если глубина (параметр depth) равна 0, разбиение не производится, и треугольники рисуются «как есть». Если задана глубина равная 1, разбиение производится 1 раз и так далее.

Пример 2-17. Рекурсивное разбиение

```c++
void subdivine(float *v1, float *v2, float *v3, long depth)
{
 	GLfloat v12[3], v23[3], v31[3];
 	GLint i;

 	if(depth==0)
 	{
 		drawTriangle(v1,v2,v3);
 		return;
 	}

 	for (i=0;i<3;i++)
 	{
 		v12[i]=(v1[i]+v2[i])/2.0;
	 	v23[i]=(v2[i]+v3[i])/2.0;
 		v31[i]=(v3[i]+v1[i])/2.0;
     }
 	normalize(v12);
 	normalize(v23);
 	normalize(v31);
 	
 	subdivine(v1,v12,v31,depth-1);
 	subdivine(v2,v23,v12,depth-1);
 	subdivine(v3,v31,v23,depth-1);
 	subdivine(v12,v23,v31,depth-1);
} 
```

### Обобщенное разбиение

Рассмотрим более обобщенное решение проблемы разбиения, считая, что некоторая поверхность параметризирована двумя переменными u[0] и u[1]. Предположим, что существует две функции: 

```c++
void surf(GLfloat u[2],GLfloat vertex[3],GLfloat normal[3]);
float curv(GLfloat u[2]); 
```

При передаче u[] функции surf(), возвращаются соответствующие трехмерные координаты вершины и вектора нормали единичной длины. Если передать u[] в функцию curv() вычисляется и возвращается кривизна поверхности в данной точке. 

В примере 2-18 представлена рекурсивная функция, которая разбивает треугольники до достижения максимального уровня вложенности или до тех пор, пока максимальная кривизна в трех вершинах треугольника не станет меньше некоторого заданного значения. 

Пример 2-18. Обобщенное разбиение

```c++
void subdivine(float u1[2],float u2[2],float u3[2],float cutoff,long depth)
{
 GLfloat v1[3],v2[3],v3[3],n1[3],n2[3],n3[3];
 GLfloat u12[2],u23[2],u31[2];
 GLint i;

 if(depth==maxdepth || (curv(u1)<cutoff))
 {
 surf(u1,v1,n1);
 surf(u2,v2,n2);
 surf(u3,v3,n3);
 glBegin(GL_POLYGON);
 glNormal3fv(n1); glVertex3fv(v1);
 glNormal3fv(n2); glVertex3fv(v2);
 glNormal3fv(n3); glVertex3fv(v3);
 glEnd();
 return;
 }

 for(i=0;i<2;i++)
 {
 u12[i]=(u1[i]+u2[i])/2.0;
 u23[i]=(u2[i]+u3[i])/2.0;
 u31[i]=(u3[i]+u1[i])/2.0;
 }
 subdivine(u1,u12,u31,cutoff,depth+1);
 subdivine(u2,u23,u12,cutoff,depth+1);
 subdivine(u3,u31,u23,cutoff,depth+1);
 subdivine(u12,u23,u31,cutoff,depth+1);
} 
```

# Глава 3. Вид

70 стр